'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

var calculateTotalDuration = ({ duration = 0.3, delay = 0, overlay = 0, }) => duration + delay - overlay || 0;

var isUndefined = (val) => val === undefined;

function getSequenceId(sequenceIndex, sequenceId, defaultValue) {
    if (isUndefined(sequenceId) && isUndefined(sequenceIndex))
        return defaultValue || 0;
    if (sequenceIndex && sequenceIndex >= 0)
        return sequenceIndex;
    if (sequenceId)
        return sequenceId;
    return 0;
}

const AnimateContext = React.createContext({
    animationStates: {},
    register: (data) => { },
});
function AnimateGroup(props) {
    const { play, sequences = [], children } = props;
    const [animationStates, setAnimationStates] = React.useState({});
    const animationsRef = React.useRef({});
    const register = (data) => {
        const { sequenceIndex, sequenceId } = data;
        if (isUndefined(sequenceId) && isUndefined(sequenceIndex))
            return;
        animationsRef.current[getSequenceId(sequenceIndex, sequenceId)] = data;
    };
    React.useEffect(() => {
        const sequencesToAnimate = Array.isArray(sequences) && sequences.length
            ? sequences
            : Object.values(animationsRef.current);
        const localAnimationState = {};
        (play ? sequencesToAnimate : [...sequencesToAnimate].reverse()).reduce((previous, current, currentIndex) => {
            const { sequenceId, sequenceIndex } = current, restAttributes = __rest(current, ["sequenceId", "sequenceIndex"]);
            const { duration: defaultDuration, delay, overlay } = restAttributes;
            const id = getSequenceId(sequenceIndex, sequenceId, currentIndex);
            const duration = defaultDuration || 0.3;
            const currentTotalDuration = calculateTotalDuration({
                duration,
                delay,
                overlay,
            });
            const totalDuration = currentTotalDuration + previous;
            localAnimationState[id] = {
                play,
                pause: !play,
                delay: currentIndex === 0
                    ? delay || 0
                    : delay
                        ? currentTotalDuration
                        : previous,
                controlled: true,
            };
            return totalDuration;
        }, 0);
        setAnimationStates(localAnimationState);
    }, [play]);
    return (React.createElement(AnimateContext.Provider, { value: { animationStates, register } }, children));
}

var secToMs = (ms) => (ms || 0) * 1000;

function Animate(props) {
    const { play, children, render, start, end, complete = '', onComplete, delay = 0, duration = 0.3, easeType = 'linear', sequenceId, sequenceIndex, } = props;
    const onCompleteTimeRef = React.useRef();
    const [style, setStyle] = React.useState(start || {});
    const { register, animationStates = {} } = React.useContext(AnimateContext);
    const id = getSequenceId(sequenceIndex, sequenceId);
    React.useEffect(() => {
        if ((!isUndefined(sequenceIndex) && sequenceIndex >= 0) || sequenceId)
            register(props);
    }, []);
    React.useEffect(() => {
        const animationState = animationStates[id] || {};
        setStyle(Object.assign(Object.assign({}, (play || animationState.play ? end : start)), { transition: `all ${duration}s ${easeType} ${parseFloat(animationState.delay || delay)}s` }));
        if (play && (complete || onComplete)) {
            onCompleteTimeRef.current = setTimeout(() => {
                complete && setStyle(complete);
                onComplete && onComplete();
            }, secToMs(parseFloat(animationState.delay || delay) + duration));
        }
        return () => {
            onCompleteTimeRef.current && clearTimeout(onCompleteTimeRef.current);
        };
    }, [
        id,
        animationStates,
        play,
        duration,
        easeType,
        delay,
        onComplete,
        start,
        end,
        complete,
    ]);
    return render ? render({ style }) : React.createElement("div", { style: style }, children);
}

var camelCaseToDash = (camelCase) => camelCase ? camelCase.replace(/[A-Z]/g, c => `-${c.toLowerCase()}`) : '';

const generateKeyframes = keyframes => {
    const animationLength = keyframes.length;
    return keyframes.reduce((previous, keyframe, currentIndex) => {
        const keyframePercentage = animationLength === 2
            ? currentIndex * 100
            : parseFloat((100 / (animationLength - 1)).toFixed(2)) * currentIndex;
        if (typeof keyframe === 'string') {
            return `${previous} ${keyframePercentage}% {${keyframe}}`;
        }
        const keys = Object.keys(keyframe);
        if (keys.length && isNaN(+keys[0])) {
            const keyframeContent = keys.reduce((acc, key) => `${acc} ${camelCaseToDash(key)}: ${keyframe[key]};`, '');
            return `${previous} ${keyframePercentage}% {${keyframeContent}}`;
        }
        return `${previous} ${Object.keys(keyframe)[0]}% {${Object.values(keyframe)[0]}}`;
    }, '');
};
function createStyle({ keyframes, animationName, }) {
    return `@keyframes ${animationName} {${generateKeyframes(keyframes)}}`;
}

function createTag({ keyframes, animationName, }) {
    let styleTag = document.querySelector('style[data-id=rsi]');
    let index;
    if (!styleTag) {
        styleTag = document.createElement('style');
        styleTag.setAttribute('data-id', 'rsi');
        document.head.appendChild(styleTag);
    }
    try {
        // @ts-ignore
        index = styleTag.sheet.cssRules.length;
    }
    catch (e) {
        index = 0;
    }
    try {
        // @ts-ignore
        styleTag.sheet.insertRule(createStyle({
            keyframes,
            animationName,
        }), index);
    }
    catch (e) {
        console.error('react simple animate, error found during insert style ', e); // eslint-disable-line no-console
    }
    return {
        styleTag,
        index,
    };
}

var deleteRules = (sheet, deleteName) => {
    const index = Object.values(sheet.cssRules).findIndex(({ name }) => name === deleteName);
    if (index >= 0)
        sheet.deleteRule(index);
};

var createRandomName = () => `RSI-${Math.random()
    .toString(36)
    .substr(2, 9)}`;

var getPlayState = (pause) => pause ? 'paused' : 'running';

function AnimateKeyframes(props) {
    const { children, play = false, pause = false, render, duration = 0.3, delay = 0, easeType = 'linear', direction = 'normal', fillMode = 'none', iterationCount = 1, sequenceIndex, keyframes, sequenceId, } = props;
    let pauseValue;
    const animationNameRef = React.useRef({
        forward: '',
        reverse: '',
    });
    const controlled = React.useRef(false);
    const styleTagRef = React.useRef({
        forward: { sheet: {} },
        reverse: { sheet: {} },
    });
    const id = getSequenceId(sequenceIndex, sequenceId);
    const { register, animationStates = {} } = React.useContext(AnimateContext);
    const [, forceUpdate] = React.useState(false);
    React.useEffect(() => {
        animationNameRef.current.forward = createRandomName();
        let result = createTag({
            animationName: animationNameRef.current.forward,
            keyframes,
        });
        styleTagRef.current.forward = result.styleTag;
        animationNameRef.current.reverse = createRandomName();
        result = createTag({
            animationName: animationNameRef.current.reverse,
            keyframes: keyframes.reverse(),
        });
        styleTagRef.current.reverse = result.styleTag;
        register(props);
        if (play)
            forceUpdate(true);
        return () => {
            deleteRules(styleTagRef.current.forward.sheet, animationNameRef.current.forward);
            deleteRules(styleTagRef.current.reverse.sheet, animationNameRef.current.reverse);
        };
    }, []);
    const animateState = animationStates[id] || {};
    if (animateState.controlled && !controlled.current) {
        pauseValue = animateState.pause;
        if (!animateState.pause)
            controlled.current = true;
    }
    else {
        pauseValue = pause;
    }
    const style = {
        animation: `${duration}s ${easeType} ${animateState.delay ||
            delay}s ${iterationCount} ${direction} ${fillMode} ${getPlayState(pauseValue)} ${((animateState.controlled
            ? animateState.play
            : play)
            ? animationNameRef.current.forward
            : animationNameRef.current.reverse) || ''}`,
    };
    return render ? render({ style }) : React.createElement("div", { style: style || {} }, children);
}

function useAnimate(props) {
    const { start, end, complete, onComplete, delay = 0, duration = 0.3, easeType = 'linear', } = props;
    const transition = React.useMemo(() => `all ${duration}s ${easeType} ${delay}s`, [duration, easeType, delay]);
    const [style, setStyle] = React.useState(Object.assign(Object.assign({}, start), { transition }));
    const [isPlaying, setIsPlaying] = React.useState(false);
    const onCompleteTimeRef = React.useRef();
    const onCompleteCallbackRef = React.useRef(onComplete);
    const playRef = React.useRef();
    React.useEffect(() => {
        onCompleteCallbackRef.current = onComplete;
    }, [onComplete]);
    React.useEffect(() => () => {
        onCompleteTimeRef.current && clearTimeout(onCompleteTimeRef.current);
    }, []);
    if (!playRef.current) {
        playRef.current = (isPlay) => {
            setStyle(Object.assign(Object.assign({}, (isPlay ? end : start)), { transition }));
            setIsPlaying(true);
            onCompleteTimeRef.current = setTimeout(() => {
                if (isPlay && (complete || onComplete)) {
                    complete && setStyle(complete);
                    onCompleteCallbackRef.current && onCompleteCallbackRef.current();
                }
                setIsPlaying(false);
            }, secToMs(delay + duration));
        };
    }
    return {
        isPlaying,
        style,
        play: playRef.current,
    };
}

function useAnimateKeyframes(props) {
    const { duration = 0.3, delay = 0, easeType = 'linear', direction = 'normal', fillMode = 'none', iterationCount = 1, keyframes, } = props;
    const animationNameRef = React.useRef({
        forward: '',
        reverse: '',
    });
    const styleTagRef = React.useRef({
        forward: { sheet: {} },
        reverse: { sheet: {} },
    });
    const { register } = React.useContext(AnimateContext);
    const [isPlaying, setIsPlaying] = React.useState(true);
    const [isPaused, setIsPaused] = React.useState(false);
    const playRef = React.useRef();
    React.useEffect(() => {
        animationNameRef.current.forward = createRandomName();
        let result = createTag({
            animationName: animationNameRef.current.forward,
            keyframes,
        });
        styleTagRef.current.forward = result.styleTag;
        animationNameRef.current.reverse = createRandomName();
        result = createTag({
            animationName: animationNameRef.current.reverse,
            keyframes: keyframes.reverse(),
        });
        styleTagRef.current.reverse = result.styleTag;
        register(props);
        return () => {
            deleteRules(styleTagRef.current.forward.sheet, animationNameRef.current.forward);
            deleteRules(styleTagRef.current.reverse.sheet, animationNameRef.current.reverse);
        };
    }, []);
    playRef.current = playRef.current
        ? playRef.current
        : (isPlay) => setIsPlaying(isPlay);
    const style = {
        animation: `${duration}s ${easeType} ${delay}s ${iterationCount} ${direction} ${fillMode} ${getPlayState(isPaused)} ${(isPlaying
            ? animationNameRef.current.forward
            : animationNameRef.current.reverse) || ''}`,
    };
    return {
        style,
        play: playRef.current,
        pause: setIsPaused,
        isPlaying,
    };
}

function createArrayWithNumbers(length) {
    return Array.from({ length }, () => null);
}

function useAnimateGroup(props) {
    const { sequences = [] } = props;
    const defaultArray = createArrayWithNumbers(sequences.length).map((_, index) => props.sequences[index].start);
    const [styles, setStyles] = React.useState(defaultArray);
    const [isPlaying, setPlaying] = React.useState(false);
    const animationNamesRef = React.useRef([]);
    const styleTagRef = React.useRef([]);
    const playRef = React.useRef();
    React.useEffect(() => {
        sequences.forEach(({ keyframes = false }, i) => {
            if (!Array.isArray(keyframes))
                return;
            if (!animationNamesRef.current[i]) {
                animationNamesRef.current[i] = {};
                styleTagRef.current[i] = {};
            }
            animationNamesRef.current[i].forward = createRandomName();
            let result = createTag({
                animationName: animationNamesRef.current[i].forward,
                keyframes,
            });
            styleTagRef.current[i].forward = result.styleTag;
            animationNamesRef.current[i].reverse = createRandomName();
            result = createTag({
                animationName: animationNamesRef.current[i].reverse,
                keyframes: keyframes.reverse(),
            });
            styleTagRef.current[i].reverse = result.styleTag;
        });
        return () => Object.values(animationNamesRef).forEach(({ forward, reverse }, i) => {
            if (!styleTagRef[i])
                return;
            deleteRules(styleTagRef[i].sheet, forward);
            deleteRules(styleTagRef[i].sheet, reverse);
        });
    }, []);
    playRef.current = playRef.current
        ? playRef.current
        : (isPlay) => {
            let totalDuration = 0;
            const animationRefWithOrder = isPlay
                ? animationNamesRef.current
                : [...animationNamesRef.current].reverse();
            const styles = (isPlay ? sequences : [...sequences].reverse()).map((current, currentIndex) => {
                const { duration = 0.3, delay = 0, overlay, keyframes, iterationCount = 1, easeType = 'linear', direction = 'normal', fillMode = 'none', end = {}, start = {}, } = current;
                const delayDuration = currentIndex === 0 ? delay : totalDuration;
                const transition = `all ${duration}s ${easeType} ${delayDuration}s`;
                totalDuration =
                    calculateTotalDuration({ duration, delay, overlay }) +
                        totalDuration;
                return keyframes
                    ? {
                        animation: `${duration}s ${easeType} ${delayDuration}s ${iterationCount} ${direction} ${fillMode} running ${isPlay
                            ? animationRefWithOrder[currentIndex].forward
                            : animationRefWithOrder[currentIndex].reverse}`,
                    }
                    : Object.assign(Object.assign({}, (isPlay ? end : start)), { transition });
            });
            setStyles(isPlay ? styles : [...styles].reverse());
            setPlaying(!isPlaying);
        };
    return { styles, play: playRef.current, isPlaying };
}

exports.Animate = Animate;
exports.AnimateGroup = AnimateGroup;
exports.AnimateKeyframes = AnimateKeyframes;
exports.useAnimate = useAnimate;
exports.useAnimateGroup = useAnimateGroup;
exports.useAnimateKeyframes = useAnimateKeyframes;
